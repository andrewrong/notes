# ScopeGuard

C++有一个机制叫做RAII(资源获得及初始化); 这是一种通过类的生命周期来做管理资源的释放和销毁，有了这个东西就可以保证C++出现资源泄漏的问题; 在标准库中有lock_guard,shard_ptr之类的，其实都是使用了这个机制，在资源初始化的时候就交付给一个guard，当guard出了自己的作用范围的时候就会自动销毁资源；

而这种工具目前还可以用到做来错误处理，比如在进行某一些操作的时候有概率是会失败的，那么当失败发生的时候就调用一些处理函数进行收尾， 有点类似于finally了，但是没那么重并且自我可控,不需要依赖C++的异常机制;

### 我的实现

按照我自己的方式实现，我可能会用传递一个函数模版过去，然后在析构函数的时候来调用这个函数; 如果是类的实例的话我可以用lambda来进行清理;但是我在看mongodb代码的时候发现了他们的一个工具类，用来完成这个功能，在里面主要是用于做错误处理，比如访问出错了需要做哪些处理之类的; 我自己简化了一下放到了自己的[代码库](https://github.com/andrewrong/base_library/blob/master/base/ScopeGuard.h)里面；

它做的抽象会更加高级一些，并且对于类方法也可以回调; 尤其是对外只需要使用`ScopeGuard`这个一个类,而且通过工厂方式来屏蔽指定模版参数，使用C++默认的推导完成; 比如

```
int main() {
    A a;
    auto scopeGuard = MakeObjGuard(a, &A::printF);
}
```

`MakeObjGuard`的模版参数通过编译器自己推导出来，省的麻烦; 而且它还加入了dismiss参数，主要是用于中止最后的回调; 因为在它的场景中如果成功了是不需要回调的;  它在里面设计了很多参数的情况，其实我觉得没必要那么麻烦，直接用lambda来进行封装就好，在lambda内部进行捕捉然后调用函数即可; 

